

/*
思路：
个位：n有几个10，就在个位上有几个1   ---->   n/10*1 + ((n%10!=0)?1:0)

十位：n有几个100，就在十位上有几个1  ---->   n/100*10 + tmp
      tmp：算的是不足百位，多余部分中1出现的个数
            if(k<19)   10;(十位：1/2/3/4/5/6/7/8/9，其中十位是1占了10个)
            else if(k<10)  0;(十位：都是0，占了0个)
            else  k-10+1;(十位：处于10-19之间，k-10+1就是1在十位出现的个数)
            
百位：n有几个1000，就在百位上有几个1  ---->  n/1000*100 + tmp
      tmp：算的是不足千位，多余部分中1出现的个数
            if(k<199)   100;(百位：1/2/3/4/5/6/7/8/9，其中百位是1占了100个)
            else if(k<100)  0;(百位：都是0，占了0个)
            else  k-100+1;(百位：处于100-199之间，k-100+1就是1在百位出现的个数)

...

更新个位：n/10*1 + tmp
      tmp：算的是不足十位，多余部分中1出现的个数
            if(k>1)   1;(个位：1/2/3/4/5/6/7/8/9，其中个位是1占了1个)
            else if(k<1)  0;(个位：都是0，占了0个)
            else  k-1+1;(个位：处于0-9之间，k-1+1就是1在个位出现的个数)


归纳：
      k=n%(i*10);// 表示多余部分数的大小
      count =(n/(i*10))*i + tmp; // 循环记录每一位上1出现的个数
      tmp：if(k>(i*2-1))   i;
           else if(k<i)    0;
           else            k-i+1;
           
      sum+=count; // 记录count的总和

返回：sum

*/

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        if(n<=0)
            return 0;
        int k=0;
        int count=0; // 记录每一位上的个数
        int sum=0; // 记录全部位上的个数
        int tmp=0; // 记录特殊情况
        int i=1;
        while(n/i)
        {
            k=n%(i*10); // 记录的是不足i位的部分
            if(k<i)
                tmp=0;
            else if(k>(i*2-1))
                tmp=i;
            else
                tmp=(k-i+1);
            
            // count表示满足i位的所有1的个数+不足i位那部分1的个数
            count=(n/(i*10))*i+tmp;
            // 记录每一位上1个数的总和
            sum+=count;
            i*=10;
        }
        return sum;
    }
};
